package com.hansholz.bestenotenapp.notifications

import android.app.Activity
import android.app.AlarmManager
import android.app.PendingIntent
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.net.ConnectivityManager
import android.net.NetworkCapabilities
import android.os.Build
import android.provider.Settings
import androidx.core.net.toUri
import java.lang.ref.WeakReference
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.launch
import tech.kotlinlang.permission.HelperHolder
import tech.kotlinlang.permission.Permission
import tech.kotlinlang.permission.result.NotificationPermissionResult

/* Pre-generated by AI */
actual object GradeNotifications {
    actual val isSupported: Boolean = true

    private const val ALARM_REQUEST_CODE = 1002

    private var applicationContext: Context? = null
    private var activityRef: WeakReference<Activity?> = WeakReference(null)
    private var alarmManager: AlarmManager? = null
    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default)

    actual fun initialize(platformContext: Any?) {
        when (platformContext) {
            is Activity -> {
                activityRef = WeakReference(platformContext)
                setApplicationContext(platformContext.applicationContext)
            }
            is Context -> setApplicationContext(platformContext.applicationContext)
        }
        ensureNotificationServiceInitialized(platformContext ?: applicationContext)
        refreshScheduling()
    }

    actual fun refreshScheduling() {
        val context = applicationContext ?: return
        if (!GradeNotificationEngine.shouldSchedule()) {
            cancelScheduledAlarms()
            return
        }
        ensureNotificationServiceInitialized(context)
        scheduleNextAlarm(context)
    }

    actual fun onSettingsUpdated() {
        refreshScheduling()
    }

    actual fun onLogin() {
        refreshScheduling()
    }

    actual fun onLogout() {
        cancelScheduledAlarms()
        GradeNotificationEngine.clearKnownGrades()
    }

    actual suspend fun requestPermission(): Boolean {
        val activity = activityRef.get()

        val permissionHelper = HelperHolder.getPermissionHelperInstance()
        val permission = Permission.Notification

        val checkPermissionResult = permissionHelper.checkIsPermissionGranted(permission)
        var granted = checkPermissionResult == NotificationPermissionResult.Granted
        if (granted) {
            requestExactAlarmPermissionIfNeeded(activity)
            return true
        }

        val requestPermissionResult = permissionHelper.requestForPermission(permission)
        granted = requestPermissionResult == NotificationPermissionResult.Granted
        if (granted) requestExactAlarmPermissionIfNeeded(activity)
        return granted
    }

    internal fun onAlarmFired(context: Context, pendingResult: BroadcastReceiver.PendingResult) {
        val appContext = applicationContext ?: context.applicationContext.also { setApplicationContext(it) }
        if (!GradeNotificationEngine.shouldSchedule()) {
            cancelScheduledAlarms()
            pendingResult.finish()
            return
        }
        ensureNotificationServiceInitialized(appContext)
        scheduleNextAlarm(appContext)
        scope.launch {
            try {
                runCheckIfPermitted(appContext)
            } finally {
                pendingResult.finish()
            }
        }
    }

    internal fun handleBootCompleted(context: Context) {
        setApplicationContext(context.applicationContext)
        ensureNotificationServiceInitialized(applicationContext)
        refreshScheduling()
    }

    private fun setApplicationContext(context: Context) {
        applicationContext = context
        if (alarmManager == null) {
            alarmManager = context.getSystemService(Context.ALARM_SERVICE) as? AlarmManager
        }
    }

    private fun scheduleNextAlarm(context: Context) {
        val triggerAtMillis = System.currentTimeMillis() + GradeNotificationEngine.getIntervalMinutes() * 60_000
        val manager = alarmManager ?: (context.getSystemService(Context.ALARM_SERVICE) as? AlarmManager)?.also {
            alarmManager = it
        }
        val pendingIntent = createPendingIntent(context)
        manager?.cancel(pendingIntent)
        try {
            manager?.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerAtMillis, pendingIntent)
        } catch (_: SecurityException) {
            manager?.set(AlarmManager.RTC_WAKEUP, triggerAtMillis, pendingIntent)
        }
    }

    private fun cancelScheduledAlarms() {
        val context = applicationContext ?: return
        val existingIntent = PendingIntent.getBroadcast(
            context,
            ALARM_REQUEST_CODE,
            Intent(context, GradeNotificationReceiver::class.java),
            PendingIntent.FLAG_NO_CREATE or PendingIntent.FLAG_IMMUTABLE
        )
        if (existingIntent != null) {
            val manager = alarmManager ?: (context.getSystemService(Context.ALARM_SERVICE) as? AlarmManager)?.also {
                alarmManager = it
            }
            manager?.cancel(existingIntent)
            existingIntent.cancel()
        }
    }

    private suspend fun runCheckIfPermitted(context: Context) {
        if (isWifiRequiredAndUnavailable(context)) {
            return
        }
        GradeNotificationEngine.runCheck()
    }

    private fun isWifiRequiredAndUnavailable(context: Context): Boolean {
        if (!GradeNotificationEngine.isWifiOnlyEnabled()) return false
        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as? ConnectivityManager ?: return true
        val network = connectivityManager.activeNetwork ?: return true
        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return true
        return !capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)
    }

    private fun ensureNotificationServiceInitialized(platformContext: Any?) {
        GradeNotificationNotifier.ensureInitialized(platformContext ?: applicationContext)
    }

    private fun requestExactAlarmPermissionIfNeeded(activity: Activity?) {
        if (activity == null || Build.VERSION.SDK_INT < Build.VERSION_CODES.S) return
        val manager = activity.getSystemService(AlarmManager::class.java) ?: return
        if (!manager.canScheduleExactAlarms()) {
            val intent = Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM).apply {
                data = "package:${'$'}{activity.packageName}".toUri()
            }
            activity.startActivity(intent)
        }
    }

    private fun createPendingIntent(context: Context): PendingIntent {
        val intent = Intent(context, GradeNotificationReceiver::class.java)
        return PendingIntent.getBroadcast(
            context,
            ALARM_REQUEST_CODE,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )
    }
}
