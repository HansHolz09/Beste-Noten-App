package com.hansholz.bestenotenapp.screens.timetable

import androidx.compose.animation.AnimatedContentScope
import androidx.compose.animation.ExperimentalSharedTransitionApi
import androidx.compose.animation.SharedTransitionScope
import androidx.compose.animation.core.Spring
import androidx.compose.animation.core.spring
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.BoxWithConstraints
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.text.TextAutoSize
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.MaterialTheme.colorScheme
import androidx.compose.material3.OutlinedCard
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.rotate
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.Layout
import androidx.compose.ui.unit.Constraints
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.hansholz.bestenotenapp.api.models.Absence
import com.hansholz.bestenotenapp.api.models.JournalLesson
import com.hansholz.bestenotenapp.components.enhanced.enhancedSharedBounds
import com.hansholz.bestenotenapp.theme.LocalThemeIsDark
import com.hansholz.bestenotenapp.utils.SimpleTime
import kotlinx.datetime.LocalDate

// Pre-generated by AI
@OptIn(ExperimentalSharedTransitionApi::class)
@Composable
fun DailyScheduleLayout(
    lessons: List<JournalLesson>,
    absences: List<Absence>,
    date: LocalDate,
    modifier: Modifier = Modifier,
    minTime: SimpleTime,
    maxTime: SimpleTime,
    sharedTransitionScope: SharedTransitionScope,
    animatedContentScope: AnimatedContentScope,
    selectedLesson: JournalLesson?,
    shownLessonPopup: JournalLesson?,
    onLessonPopupOpened: (JournalLesson) -> Unit,
) {
    val sortedLessons =
        lessons
            .sortedBy { it.nr }
            .mapIndexed { index, lesson ->
                val startTime = SimpleTime.parse("07:30").plus(50 * index)
                if (lesson.time?.from == null || lesson.time.to == null) {
                    lesson.copy(time = lesson.time?.copy(from = startTime.toString(), to = startTime.plus(45).toString()))
                } else {
                    lesson
                }
            }

    with(sharedTransitionScope) {
        Layout(
            modifier = modifier,
            content = {
                val isDark = LocalThemeIsDark.current
                sortedLessons.forEach { lesson ->
                    Box {
                        if (shownLessonPopup != lesson) {
                            OutlinedCard(
                                onClick = {
                                    onLessonPopupOpened(lesson)
                                },
                                modifier =
                                    Modifier
                                        .fillMaxSize()
                                        .padding(horizontal = 4.dp)
                                        .enhancedSharedBounds(
                                            sharedTransitionScope = sharedTransitionScope,
                                            sharedContentState = rememberSharedContentState(lesson),
                                            animatedVisibilityScope = animatedContentScope,
                                            enter = fadeIn(initialAlpha = if (selectedLesson == lesson) 0f else 1f),
                                            exit = fadeOut(targetAlpha = if (selectedLesson == lesson) 0f else 1f),
                                            boundsTransform = { _, _ ->
                                                spring(Spring.DampingRatioLowBouncy, Spring.StiffnessMediumLow)
                                            },
                                            resizeMode = SharedTransitionScope.ResizeMode.RemeasureToBounds,
                                            renderInOverlayDuringTransition = selectedLesson == lesson,
                                        ),
                                colors =
                                    CardDefaults.outlinedCardColors(
                                        containerColor =
                                            when (lesson.status) {
                                                "hold" -> if (isDark) Color(48, 99, 57) else Color(226, 251, 232)
                                                "canceled" -> colorScheme.errorContainer
                                                "initial" -> if (isDark) Color.DarkGray else Color.LightGray
                                                "planned" -> if (isDark) Color(38, 63, 168) else Color(222, 233, 252)
                                                else -> colorScheme.surface
                                            }.copy(0.7f),
                                    ),
                                border =
                                    BorderStroke(
                                        width = 2.dp,
                                        color =
                                            if (lesson.notes.isNullOrEmpty()) {
                                                colorScheme.outline
                                            } else {
                                                lesson.notes
                                                    .firstOrNull()
                                                    ?.type
                                                    ?.color
                                                    ?.let { Color(it.removePrefix("#").toLong(16) or 0x00000000FF000000) }
                                                    ?: if (!isDark) Color(38, 63, 168) else Color(222, 233, 252)
                                            },
                                    ),
                            ) {
                                BoxWithConstraints(
                                    modifier = Modifier.fillMaxSize(),
                                    contentAlignment = Alignment.Center,
                                ) {
                                    val flip = (maxWidth.value * 1.5f) <= maxHeight.value
                                    Text(
                                        text = lesson.subject?.localId ?: "?",
                                        modifier =
                                            Modifier
                                                .rotate(if (flip) -90f else 0f)
                                                .padding(3.dp, 6.dp)
                                                .skipToLookaheadSize(),
                                        autoSize = TextAutoSize.StepBased(minFontSize = 7.5.sp, maxFontSize = 50.sp, 5.sp),
                                        maxLines = 1,
                                        color =
                                            if (absences.any {
                                                    LocalDate.parse(it.from.take(10)) == date &&
                                                        SimpleTime.parse(it.from.takeLast(8)) <= SimpleTime.parse(lesson.time?.from ?: "00:00") &&
                                                        SimpleTime.parse(it.to.takeLast(8)) >= SimpleTime.parse(lesson.time?.to ?: "23:59")
                                                }
                                            ) {
                                                colorScheme.error
                                            } else {
                                                Color.Unspecified
                                            },
                                    )
                                }
                            }
                        }
                    }
                }
            },
        ) { measurables, constraints ->
            val placements = mutableMapOf<Int, LessonPlacementInfo>()
            val totalDurationInMinutes = minTime.minutesUntil(maxTime)

            if (totalDurationInMinutes <= 0) {
                return@Layout layout(constraints.maxWidth, constraints.maxHeight) {}
            }

            val minutesPerPx = totalDurationInMinutes.toFloat() / constraints.maxHeight.toFloat()

            for (i in sortedLessons.indices) {
                if (placements.containsKey(i)) continue

                val lessonA = sortedLessons[i]
                val lessonAEnd = SimpleTime.parse(lessonA.time?.to ?: "00:00")

                val overlappingGroupIndices = mutableListOf(i)
                for (j in (i + 1) until sortedLessons.size) {
                    val lessonB = sortedLessons[j]
                    val lessonBStart = SimpleTime.parse(lessonB.time?.from ?: "00:00")
                    if (lessonBStart < lessonAEnd) {
                        overlappingGroupIndices.add(j)
                    }
                }

                val groupItemWidth = constraints.maxWidth / overlappingGroupIndices.size

                overlappingGroupIndices.forEachIndexed { groupIndex, lessonIndex ->
                    val lesson = sortedLessons[lessonIndex]
                    val lessonStart = SimpleTime.parse(lesson.time?.from ?: "00:00")
                    val lessonEnd = SimpleTime.parse(lesson.time?.to ?: "00:00")

                    val xPos = groupIndex * groupItemWidth
                    val yPos = (minTime.minutesUntil(lessonStart) / minutesPerPx).toInt()
                    val itemHeight = (lessonStart.minutesUntil(lessonEnd) / minutesPerPx).toInt()

                    placements[lessonIndex] = LessonPlacementInfo(xPos, yPos, groupItemWidth, itemHeight)
                }
            }

            val placeables =
                measurables.mapIndexed { index, measurable ->
                    val p = placements[index]!!
                    measurable.measure(
                        Constraints.fixed(width = p.width, height = p.height),
                    )
                }

            layout(constraints.maxWidth, constraints.maxHeight) {
                placeables.forEachIndexed { index, placeable ->
                    val p = placements[index]!!
                    placeable.placeRelative(x = p.x, y = p.y)
                }
            }
        }
    }
}

private data class LessonPlacementInfo(
    val x: Int,
    val y: Int,
    val width: Int,
    val height: Int,
)
