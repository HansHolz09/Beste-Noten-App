package com.hansholz.bestenotenapp.demo

import com.hansholz.bestenotenapp.api.models.Conductor
import com.hansholz.bestenotenapp.api.models.Grade
import com.hansholz.bestenotenapp.api.models.GradeCollection
import com.hansholz.bestenotenapp.api.models.History
import com.hansholz.bestenotenapp.api.models.Interval
import com.hansholz.bestenotenapp.api.models.JournalDay
import com.hansholz.bestenotenapp.api.models.JournalLesson
import com.hansholz.bestenotenapp.api.models.JournalNote
import com.hansholz.bestenotenapp.api.models.JournalNoteType
import com.hansholz.bestenotenapp.api.models.JournalWeek
import com.hansholz.bestenotenapp.api.models.Room
import com.hansholz.bestenotenapp.api.models.Student
import com.hansholz.bestenotenapp.api.models.Subject
import com.hansholz.bestenotenapp.api.models.Teacher
import com.hansholz.bestenotenapp.api.models.TimeTable
import com.hansholz.bestenotenapp.api.models.TimeTableLesson
import com.hansholz.bestenotenapp.api.models.TimeTableTimeLesson
import com.hansholz.bestenotenapp.api.models.Year
import com.hansholz.bestenotenapp.utils.weekOfYear
import kotlin.random.Random
import kotlin.time.Clock
import kotlin.time.ExperimentalTime
import kotlinx.datetime.DateTimeUnit
import kotlinx.datetime.LocalDate
import kotlinx.datetime.TimeZone
import kotlinx.datetime.daysUntil
import kotlinx.datetime.isoDayNumber
import kotlinx.datetime.minus
import kotlinx.datetime.plus
import kotlinx.datetime.toLocalDateTime

/* Pre-generated by AI */
object DemoDataGenerator {
    data class DemoInitData(
        val years: List<Year>,
        val subjects: List<Subject>,
        val gradeCollections: List<GradeCollection>,
        val timeTable: TimeTable,
        val currentGrade: Int,
        val weekPlan: List<List<Subject>>,
        val student: Student
    )

    private val timeSlots = listOf(
        "07:35" to "08:20",
        "08:25" to "09:10",
        "09:30" to "10:15",
        "10:20" to "11:05",
        "11:15" to "12:00",
        "12:40" to "13:25",
        "13:30" to "14:15",
        "14:20" to "15:05"
    )

    private val firstNames = listOf("Anna", "Ben", "Clara", "David", "Eva", "Finn", "Julia", "Lukas", "Mia", "Noah")
    private val lastNames = listOf("Müller", "Schmidt", "Schneider", "Fischer", "Weber", "Meyer")

    private val subjectsByGrade: Map<Int, List<Pair<String, String>>> = mapOf(
        4 to listOf("Deutsch" to "DE", "Mathematik" to "MA", "Sachkunde" to "SU", "Englisch" to "EN", "Kunst" to "KU", "Musik" to "MU", "Sport" to "SPO"),
        5 to listOf("Deutsch" to "DE", "Mathematik" to "MA", "Englisch" to "EN", "Biologie" to "BIO", "Geographie" to "GEO", "Geschichte" to "GE", "Kunst" to "KU", "Musik" to "MU", "Sport" to "SPO", "Technik/Computer" to "TC"),
        6 to listOf("Deutsch" to "DE", "Mathematik" to "MA", "Englisch" to "EN", "Biologie" to "BIO", "Geographie" to "GEO", "Geschichte" to "GE", "Kunst" to "KU", "Musik" to "MU", "Sport" to "SPO", "Technik/Computer" to "TC"),
        7 to listOf("Deutsch" to "DE", "Mathematik" to "MA", "Englisch" to "EN", "Biologie" to "BIO", "Chemie" to "CH", "Physik" to "PH", "Geschichte" to "GE", "Geographie" to "GEO", "Kunst" to "KU", "Musik" to "MU", "Sport" to "SPO", "Informatik" to "INF"),
        8 to listOf("Deutsch" to "DE", "Mathematik" to "MA", "Englisch" to "EN", "Biologie" to "BIO", "Chemie" to "CH", "Physik" to "PH", "Geschichte" to "GE", "Geographie" to "GEO", "Gemeinschaftskunde/Rechtserziehung/Wirtschaft" to "GRW", "Kunst" to "KU", "Musik" to "MU", "Sport" to "SPO", "Informatik" to "INF"),
        9 to listOf("Deutsch" to "DE", "Mathematik" to "MA", "Englisch" to "EN", "Biologie" to "BIO", "Chemie" to "CH", "Physik" to "PH", "Geschichte" to "GE", "Geographie" to "GEO", "Gemeinschaftskunde/Rechtserziehung/Wirtschaft" to "GRW", "Kunst" to "KU", "Musik" to "MU", "Sport" to "SPO", "Informatik" to "INF"),
        10 to listOf("Deutsch" to "DE", "Mathematik" to "MA", "Englisch" to "EN", "Biologie" to "BIO", "Chemie" to "CH", "Physik" to "PH", "Geschichte" to "GE", "Geographie" to "GEO", "Gemeinschaftskunde/Rechtserziehung/Wirtschaft" to "GRW", "Kunst" to "KU", "Musik" to "MU", "Sport" to "SPO", "Informatik" to "INF")
    )

    @OptIn(ExperimentalTime::class)
    fun generateInitialData(): DemoInitData {
        val now = Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault()).date
        val numYears = Random.nextInt(3, 7)
        val startGrade = Random.nextInt(4, 11 - numYears)
        val years = mutableListOf<Year>()
        val subjects = mutableListOf<Subject>()
        val gradeCollections = mutableListOf<GradeCollection>()
        val subjectMap = mutableMapOf<String, Subject>()
        var collectionId = 1
        var gradeId = 1
        var subjectId = 1
        val weekPlan = mutableListOf<List<Subject>>()
        val student = Student(
            id = 1,
            forename = firstNames.random(),
            name = lastNames.random(),
            isAdult = 0
        )

        for (i in 0 until numYears) {
            val grade = startGrade + i
            val startYear = now.year - (numYears - 1 - i)
            val from = LocalDate(startYear, 8, 1)
            val to = LocalDate(startYear + 1, 7, 31)
            val year = Year(
                id = i + 1,
                ids = listOf((i + 1).toString()),
                name = "${startYear}/${startYear + 1}",
                from = from.toString(),
                to = to.toString(),
                intervals = null
            )
            years.add(year)
            val gradeSubjects = subjectsByGrade[grade] ?: subjectsByGrade[10]!!
            gradeSubjects.forEach { (name, local) ->
                if (subjectMap[name] == null) {
                    val firstName = firstNames.random()
                    val lastName = lastNames.random()
                    val teacher = Teacher(
                        id = 0,
                        localId = "${firstName.take(1)}${lastName.take(1)}",
                        forename = firstName,
                        name = lastName
                    )
                    val subject = Subject(
                        id = subjectId,
                        localId = local,
                        name = name,
                        teachers = listOf(teacher)
                    )
                    subjectMap[name] = subject
                    subjects.add(subject)
                    subjectId++
                }
            }
            val collectionsCount = Random.nextInt(30, 100)
            repeat(collectionsCount) {
                val subject = gradeSubjects.random().let { subjectMap[it.first]!! }
                val teacher = subject.teachers?.first()
                val daysBetween = from.daysUntil(to)
                val gradeDate = from.plus(Random.nextInt(daysBetween), DateTimeUnit.DAY)
                val gradeValue = when (Random.nextInt(100)) {
                    in 0..15 -> "1"
                    in 16..45 -> "2"
                    in 46..80 -> "3"
                    in 81..92 -> "4"
                    in 93..98 -> "5"
                    else -> "6"
                }
                val gradeType = listOf("Klassenarbeit", "Test", "Mündlich", "Sonstige").random()
                val conductor = Conductor(teacher!!.id!!, teacher.localId, teacher.forename, teacher.name)
                val gradHistory = mutableListOf(History(0, "grade", 0, "Created", conductorType = "teacher", conductor = conductor))
                if (Random.nextInt(15) == 0) {
                    val boy = when (gradeValue) {
                        "1" -> "Updated Value ('2' -> '1')"
                        "2" -> "Updated Value ('3' -> '2')"
                        "3" -> "Updated Value ('4' -> '3')"
                        "4" -> "Updated Value ('5' -> '4')"
                        "5" -> "Updated Value ('6' -> '5')"
                        else -> "Updated Value ('5' -> '6')"
                    }
                    gradHistory += History(0, "grade", 0, boy, conductorType = "teacher", conductor = conductor)
                }

                gradeCollections.add(
                    GradeCollection(
                        id = collectionId++,
                        type = gradeType,
                        weighting = 0,
                        name = "Name der Leistung",
                        givenAt = gradeDate.toString(),
                        intervalId = year.id,
                        subjectId = subject.id!!,
                        teacherId = teacher.id,
                        subject = subject,
                        teacher = teacher,
                        interval = Interval(year.id, year.name, "", year.from, year.to, "", null, emptyList(), year.id),
                        grades = if (Random.nextInt(5) != 0) listOf(
                            Grade(
                                id = gradeId++,
                                value = gradeValue,
                                givenAt = gradeDate.toString(),
                                histories = gradHistory
                            )
                        ) else emptyList()
                    )
                )
            }
            if (i == numYears - 1) {
                repeat(5) {
                    val lessonsCount = Random.nextInt(5, 9)
                    val subjectsForDay = mutableListOf<Subject>()
                    repeat(lessonsCount) {
                        val subj = gradeSubjects.random().let { subjectMap[it.first]!! }
                        subjectsForDay.add(subj)
                    }
                    weekPlan.add(subjectsForDay)
                }
            }
        }
        val timeTable = TimeTable(
            id = "0",
            name = "name",
            validFrom = "?",
            validTo = "?",
            weeks = null,
            noSchoolDates = null,
            lessons = generateJournalWeek(Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault()).date, weekPlan).days?.flatMap { it.lessons.orEmpty() }?.map {
                TimeTableLesson(0, 0, it.nr, it.subject, null, it.teachers, it.rooms)
            }
        )
        return DemoInitData(years, subjects, gradeCollections, timeTable, startGrade + numYears - 1, weekPlan, student)
    }

    @OptIn(ExperimentalTime::class)
    fun generateJournalWeek(date: LocalDate, weekPlan: List<List<Subject>>): JournalWeek {
        val monday = date.minus(date.dayOfWeek.isoDayNumber - 1, DateTimeUnit.DAY)
        val nowDate = Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault()).date
        val days = mutableListOf<JournalDay>()
        weekPlan.forEachIndexed { dayIndex, plan ->
            val dayDate = monday.plus(dayIndex, DateTimeUnit.DAY)
            val lessons = plan.mapIndexed { lessonIndex, subject ->
                val slot = timeSlots[lessonIndex]
                val status = if (dayDate < nowDate) {
                    if (Random.nextInt(100) < 90) "hold" else "canceled"
                } else if (dayDate > nowDate) {
                    if (Random.nextInt(100) < 90) "planned" else "canceled"
                } else {
                    val rnd = Random.nextInt(100)
                    when {
                        rnd < 70 -> "hold"
                        rnd < 80 -> "canceled"
                        else -> "planned"
                    }
                }
                val rndNote = Random.nextInt(100)
                val notes = when {
                    rndNote < 5 -> listOf(JournalNote(
                        description = "Thema des Tests",
                        type = JournalNoteType(name = "Test", color = "#27F54D")
                    ))
                    rndNote < 8 -> listOf(JournalNote(
                        description = "Thema der Klassenarbeit",
                        type = JournalNoteType(name = "Klassenarbeit", color = "#F54927")
                    ))
                    rndNote < 10 -> listOf(JournalNote(
                        description = "In dieser Stunde findet irgendein besonderes Ereignis statt",
                        type = JournalNoteType(name = "Ereignis")
                    ))
                    else -> emptyList()
                }

                JournalLesson(
                    id = "demo-${dayIndex}-${lessonIndex}",
                    nr = (lessonIndex + 1).toString(),
                    status = status,
                    times = listOf(
                        TimeTableTimeLesson(
                            id = "time-${lessonIndex + 1}",
                            nr = (lessonIndex + 1).toString(),
                            from = slot.first,
                            to = slot.second
                        )
                    ),
                    time = TimeTableTimeLesson(
                        id = "time-${lessonIndex + 1}",
                        nr = (lessonIndex + 1).toString(),
                        from = slot.first,
                        to = slot.second
                    ),
                    subject = subject,
                    teachers = subject.teachers,
                    rooms = listOf(Room(id = lessonIndex, localId = "R${Random.nextInt(100, 300)}")),
                    notes = notes,
                )
            }
            days.add(
                JournalDay(
                    id = "day-${dayIndex}",
                    date = dayDate.toString(),
                    lessons = lessons
                )
            )
        }
        val weekId = "${monday.year}-${monday.weekOfYear}"
        return JournalWeek(
            id = weekId,
            calendarYear = monday.year,
            nr = monday.weekOfYear,
            days = days
        )
    }
}

