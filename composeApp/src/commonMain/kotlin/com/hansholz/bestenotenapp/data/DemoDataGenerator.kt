package com.hansholz.bestenotenapp.data

import com.hansholz.bestenotenapp.api.models.Absence
import com.hansholz.bestenotenapp.api.models.AbsenceType
import com.hansholz.bestenotenapp.api.models.AbsenceVerification
import com.hansholz.bestenotenapp.api.models.Conductor
import com.hansholz.bestenotenapp.api.models.Grade
import com.hansholz.bestenotenapp.api.models.GradeCollection
import com.hansholz.bestenotenapp.api.models.History
import com.hansholz.bestenotenapp.api.models.Interval
import com.hansholz.bestenotenapp.api.models.JournalDay
import com.hansholz.bestenotenapp.api.models.JournalDayStudentCount
import com.hansholz.bestenotenapp.api.models.JournalLesson
import com.hansholz.bestenotenapp.api.models.JournalLessonStudentCount
import com.hansholz.bestenotenapp.api.models.JournalNote
import com.hansholz.bestenotenapp.api.models.JournalNoteType
import com.hansholz.bestenotenapp.api.models.JournalWeek
import com.hansholz.bestenotenapp.api.models.Room
import com.hansholz.bestenotenapp.api.models.Student
import com.hansholz.bestenotenapp.api.models.Subject
import com.hansholz.bestenotenapp.api.models.Teacher
import com.hansholz.bestenotenapp.api.models.TimeTable
import com.hansholz.bestenotenapp.api.models.TimeTableLesson
import com.hansholz.bestenotenapp.api.models.TimeTableTimeLesson
import com.hansholz.bestenotenapp.api.models.Year
import com.hansholz.bestenotenapp.utils.weekOfYear
import kotlinx.datetime.DateTimeUnit
import kotlinx.datetime.DayOfWeek
import kotlinx.datetime.LocalDate
import kotlinx.datetime.TimeZone
import kotlinx.datetime.daysUntil
import kotlinx.datetime.isoDayNumber
import kotlinx.datetime.minus
import kotlinx.datetime.number
import kotlinx.datetime.plus
import kotlinx.datetime.toLocalDateTime
import kotlin.random.Random
import kotlin.time.Clock
import kotlin.time.ExperimentalTime

// Pre-generated by AI
object DemoDataGenerator {
    data class DemoInitData(
        val years: List<Year>,
        val subjects: List<Subject>,
        val gradeCollections: List<GradeCollection>,
        val timeTable: TimeTable,
        val currentGrade: Int,
        val weekPlan: List<List<Subject>>,
        val student: Student,
        val intervalsByYear: Map<Int, List<Interval>>,
        val absencesByYear: Map<Int, List<Absence>>,
        val dayStudentCountsByYear: Map<Int, JournalDayStudentCount>,
        val lessonStudentCountsByYear: Map<Int, JournalLessonStudentCount>,
        val totalDayStudentCount: JournalDayStudentCount,
        val totalLessonStudentCount: JournalLessonStudentCount,
    )

    private data class DemoAttendanceData(
        val schoolDays: Int,
        val lessonCount: Int,
        val notPresentDaysWithAbsence: Int,
        val notPresentDaysWithoutAbsence: Int,
        val notPresentLessonsWithAbsence: Int,
        val notPresentLessonsWithoutAbsence: Int,
        val tooLateSum: Int,
        val tooEarlySum: Int,
        val missingHomeworkSum: Int,
        val missingEquipmentSum: Int,
    )

    private val timeSlots =
        listOf(
            "07:35" to "08:20",
            "08:25" to "09:10",
            "09:30" to "10:15",
            "10:20" to "11:05",
            "11:15" to "12:00",
            "12:40" to "13:25",
            "13:30" to "14:15",
            "14:20" to "15:05",
        )

    private val firstNames = listOf("Anna", "Ben", "Clara", "David", "Eva", "Finn", "Julia", "Lukas", "Mia", "Noah")
    private val lastNames = listOf("Müller", "Schmidt", "Schneider", "Fischer", "Weber", "Meyer")

    private val subjectsByGrade: Map<Int, List<Pair<String, String>>> =
        mapOf(
            4 to listOf("Deutsch" to "DE", "Mathematik" to "MA", "Sachkunde" to "SU", "Englisch" to "EN", "Kunst" to "KU", "Musik" to "MU", "Sport" to "SPO"),
            5 to
                listOf(
                    "Deutsch" to "DE",
                    "Mathematik" to "MA",
                    "Englisch" to "EN",
                    "Biologie" to "BIO",
                    "Geographie" to "GEO",
                    "Geschichte" to "GE",
                    "Kunst" to "KU",
                    "Musik" to "MU",
                    "Sport" to "SPO",
                    "Technik/Computer" to "TC",
                ),
            6 to
                listOf(
                    "Deutsch" to "DE",
                    "Mathematik" to "MA",
                    "Englisch" to "EN",
                    "Biologie" to "BIO",
                    "Geographie" to "GEO",
                    "Geschichte" to "GE",
                    "Kunst" to "KU",
                    "Musik" to "MU",
                    "Sport" to "SPO",
                    "Technik/Computer" to "TC",
                ),
            7 to
                listOf(
                    "Deutsch" to "DE",
                    "Mathematik" to "MA",
                    "Englisch" to "EN",
                    "Biologie" to "BIO",
                    "Chemie" to "CH",
                    "Physik" to "PH",
                    "Geschichte" to "GE",
                    "Geographie" to "GEO",
                    "Kunst" to "KU",
                    "Musik" to "MU",
                    "Sport" to "SPO",
                    "Informatik" to "INF",
                ),
            8 to
                listOf(
                    "Deutsch" to "DE",
                    "Mathematik" to "MA",
                    "Englisch" to "EN",
                    "Biologie" to "BIO",
                    "Chemie" to "CH",
                    "Physik" to "PH",
                    "Geschichte" to "GE",
                    "Geographie" to "GEO",
                    "Gemeinschaftskunde/Rechtserziehung/Wirtschaft" to "GRW",
                    "Kunst" to "KU",
                    "Musik" to "MU",
                    "Sport" to "SPO",
                    "Informatik" to "INF",
                ),
            9 to
                listOf(
                    "Deutsch" to "DE",
                    "Mathematik" to "MA",
                    "Englisch" to "EN",
                    "Biologie" to "BIO",
                    "Chemie" to "CH",
                    "Physik" to "PH",
                    "Geschichte" to "GE",
                    "Geographie" to "GEO",
                    "Gemeinschaftskunde/Rechtserziehung/Wirtschaft" to "GRW",
                    "Kunst" to "KU",
                    "Musik" to "MU",
                    "Sport" to "SPO",
                    "Informatik" to "INF",
                ),
            10 to
                listOf(
                    "Deutsch" to "DE",
                    "Mathematik" to "MA",
                    "Englisch" to "EN",
                    "Biologie" to "BIO",
                    "Chemie" to "CH",
                    "Physik" to "PH",
                    "Geschichte" to "GE",
                    "Geographie" to "GEO",
                    "Gemeinschaftskunde/Rechtserziehung/Wirtschaft" to "GRW",
                    "Kunst" to "KU",
                    "Musik" to "MU",
                    "Sport" to "SPO",
                    "Informatik" to "INF",
                ),
        )

    @OptIn(ExperimentalTime::class)
    fun generateInitialData(): DemoInitData {
        val now =
            Clock.System
                .now()
                .toLocalDateTime(TimeZone.currentSystemDefault())
                .date
        val currentSchoolYearStart = if (now.month.number < 8) now.year - 1 else now.year
        val numYears = Random.nextInt(3, 7)
        val startGrade = Random.nextInt(4, 11 - numYears)
        val firstSchoolYearStart = currentSchoolYearStart - (numYears - 1)
        val years = mutableListOf<Year>()
        val subjects = mutableListOf<Subject>()
        val gradeCollections = mutableListOf<GradeCollection>()
        val subjectMap = mutableMapOf<String, Subject>()
        var collectionId = 1
        var gradeId = 1
        var subjectId = 1
        val weekPlan = mutableListOf<List<Subject>>()
        val student =
            Student(
                id = 1,
                forename = firstNames.random(),
                name = lastNames.random(),
                isAdult = 0,
            )

        for (i in 0 until numYears) {
            val grade = startGrade + i
            val startYear = firstSchoolYearStart + i
            val from = LocalDate(startYear, 8, 1)
            val to = LocalDate(startYear + 1, 7, 31)
            val year =
                Year(
                    id = i + 1,
                    ids = listOf((i + 1).toString()),
                    name = "$startYear/${startYear + 1}",
                    from = from.toString(),
                    to = to.toString(),
                    intervals = null,
                )
            years.add(year)
            val gradeSubjects = subjectsByGrade[grade] ?: subjectsByGrade[10]!!
            gradeSubjects.forEach { (name, local) ->
                if (subjectMap[name] == null) {
                    val firstName = firstNames.random()
                    val lastName = lastNames.random()
                    val teacher =
                        Teacher(
                            id = 0,
                            localId = "${firstName.take(1)}${lastName.take(1)}",
                            forename = firstName,
                            name = lastName,
                        )
                    val subject =
                        Subject(
                            id = subjectId,
                            localId = local,
                            name = name,
                            teachers = listOf(teacher),
                        )
                    subjectMap[name] = subject
                    subjects.add(subject)
                    subjectId++
                }
            }
            val collectionsCount = Random.nextInt(30, 100)
            repeat(collectionsCount) {
                val subject = gradeSubjects.random().let { subjectMap[it.first]!! }
                val teacher = subject.teachers?.first()
                val daysBetween = from.daysUntil(to)
                val gradeDate = from.plus(Random.nextInt(daysBetween), DateTimeUnit.DAY)
                val gradeValue =
                    when (Random.nextInt(100)) {
                        in 0..15 -> "1"
                        in 16..45 -> "2"
                        in 46..80 -> "3"
                        in 81..92 -> "4"
                        in 93..98 -> "5"
                        else -> "6"
                    }
                val gradeType = listOf("Klassenarbeit", "Test", "Mündlich", "Sonstige").random()
                val conductor = Conductor(teacher!!.id!!, teacher.localId, teacher.forename, teacher.name)
                val gradHistory = mutableListOf(History(0, "grade", 0, "Created", conductorType = "teacher", conductor = conductor))
                if (Random.nextInt(15) == 0) {
                    val boy =
                        when (gradeValue) {
                            "1" -> "Updated Value ('2' -> '1')"
                            "2" -> "Updated Value ('3' -> '2')"
                            "3" -> "Updated Value ('4' -> '3')"
                            "4" -> "Updated Value ('5' -> '4')"
                            "5" -> "Updated Value ('6' -> '5')"
                            else -> "Updated Value ('5' -> '6')"
                        }
                    gradHistory += History(0, "grade", 0, boy, conductorType = "teacher", conductor = conductor)
                }

                gradeCollections.add(
                    GradeCollection(
                        id = collectionId++,
                        type = gradeType,
                        weighting = 0,
                        name = "Name der Leistung",
                        givenAt = gradeDate.toString(),
                        intervalId = year.id,
                        subjectId = subject.id!!,
                        teacherId = teacher.id,
                        subject = subject,
                        teacher = teacher,
                        interval = Interval(year.id, year.name, "", year.from, year.to, "", null, emptyList(), year.id),
                        grades =
                            if (Random.nextInt(5) != 0) {
                                listOf(
                                    Grade(
                                        id = gradeId++,
                                        value = gradeValue,
                                        givenAt = gradeDate.toString(),
                                        histories = gradHistory,
                                    ),
                                )
                            } else {
                                emptyList()
                            },
                    ),
                )
            }
            if (i == numYears - 1) {
                repeat(5) {
                    val lessonsCount = Random.nextInt(5, 9)
                    val subjectsForDay = mutableListOf<Subject>()
                    repeat(lessonsCount) {
                        val subj = gradeSubjects.random().let { subjectMap[it.first]!! }
                        subjectsForDay.add(subj)
                    }
                    weekPlan.add(subjectsForDay)
                }
            }
        }
        val timeTable =
            TimeTable(
                id = "0",
                name = "name",
                validFrom = "?",
                validTo = "?",
                weeks = null,
                noSchoolDates = null,
                lessons =
                    generateJournalWeek(
                        Clock.System
                            .now()
                            .toLocalDateTime(TimeZone.currentSystemDefault())
                            .date,
                        weekPlan,
                    ).days?.flatMap { it.lessons.orEmpty() }?.map {
                        TimeTableLesson(0, 0, it.nr, it.subject, null, it.teachers, it.rooms)
                    },
            )

        val intervalsByYear = years.associate { year -> year.id to generateIntervalsForYear(year) }
        val absencesByYear = years.associate { year -> year.id to generateAbsencesForYear(year, student, subjects, weekPlan, now) }

        val dayStudentCountsByYear = mutableMapOf<Int, JournalDayStudentCount>()
        val lessonStudentCountsByYear = mutableMapOf<Int, JournalLessonStudentCount>()
        years.forEachIndexed { index, year ->
            val attendanceData = generateAttendanceData(isCurrentYear = index == years.lastIndex)
            dayStudentCountsByYear[year.id] = attendanceData.toDayStudentCount(student)
            lessonStudentCountsByYear[year.id] = attendanceData.toLessonStudentCount(student)
        }

        val totalDayStudentCount =
            JournalDayStudentCount(
                count = dayStudentCountsByYear.values.sumOf { it.count ?: 0 },
                lessonsCount = lessonStudentCountsByYear.values.sumOf { it.count ?: 0 }.toString(),
                notPresentCount = dayStudentCountsByYear.values.sumOf { it.notPresentCount ?: 0 },
                notPresentWithAbsenceCount = dayStudentCountsByYear.values.sumOf { it.notPresentWithAbsenceCount ?: 0 },
                notPresentWithoutAbsenceCount = dayStudentCountsByYear.values.sumOf { it.notPresentWithoutAbsenceCount ?: 0 },
                studentId = student.id,
                student = student,
            )
        val totalLessonStudentCount =
            JournalLessonStudentCount(
                count = lessonStudentCountsByYear.values.sumOf { it.count ?: 0 },
                notPresentCount = lessonStudentCountsByYear.values.sumOf { it.notPresentCount ?: 0 },
                notPresentWithAbsenceCount = lessonStudentCountsByYear.values.sumOf { it.notPresentWithAbsenceCount ?: 0 },
                tooLateSum = lessonStudentCountsByYear.values.sumOf { it.tooLateSum ?: 0 },
                tooEarlySum = lessonStudentCountsByYear.values.sumOf { it.tooEarlySum ?: 0 },
                missingHomeworkSum = lessonStudentCountsByYear.values.sumOf { it.missingHomeworkSum ?: 0 },
                missingEquipmentSum = lessonStudentCountsByYear.values.sumOf { it.missingEquipmentSum ?: 0 },
                studentId = student.id,
                student = student,
            )

        return DemoInitData(
            years = years,
            subjects = subjects,
            gradeCollections = gradeCollections,
            timeTable = timeTable,
            currentGrade = startGrade + numYears - 1,
            weekPlan = weekPlan,
            student = student,
            intervalsByYear = intervalsByYear,
            absencesByYear = absencesByYear,
            dayStudentCountsByYear = dayStudentCountsByYear,
            lessonStudentCountsByYear = lessonStudentCountsByYear,
            totalDayStudentCount = totalDayStudentCount,
            totalLessonStudentCount = totalLessonStudentCount,
        )
    }

    @OptIn(ExperimentalTime::class)
    fun generateJournalWeek(
        date: LocalDate,
        weekPlan: List<List<Subject>>,
    ): JournalWeek {
        val monday = date.minus(date.dayOfWeek.isoDayNumber - 1, DateTimeUnit.DAY)
        val nowDate =
            Clock.System
                .now()
                .toLocalDateTime(TimeZone.currentSystemDefault())
                .date
        val days = mutableListOf<JournalDay>()
        weekPlan.forEachIndexed { dayIndex, plan ->
            val dayDate = monday.plus(dayIndex, DateTimeUnit.DAY)
            val dayRnd = Random.nextInt(100)
            val dayNotes =
                when {
                    dayRnd < 25 ->
                        listOf(
                            JournalNote(
                                description =
                                    listOf(
                                        "Die Programmier-AG muss heute leider ausfallen.",
                                        "Die Informatik-AG muss heute leider ausfallen.",
                                        "Die Robotik-AG muss heute leider ausfallen.",
                                        "Heute findet ab 15:00 Uhr der Nachschreibetermin im Zimmer R100 statt.",
                                        "Diese Woche entfällt der Nachschreibetermin.",
                                        "Aufgrund einer Schulveranstaltung kann es heute vermehrt zu Ausfällen kommen.",
                                    ).random(),
                            ),
                        )
                    dayRnd < 40 ->
                        listOf(
                            JournalNote(
                                description =
                                    listOf(
                                        "Die Programmier-AG muss heute leider ausfallen.",
                                        "Die Informatik-AG muss heute leider ausfallen.",
                                        "Die Robotik-AG muss heute leider ausfallen.",
                                        "Heute findet ab 15 Uhr der Nachschreibetermin im Zimmer R100 statt.",
                                        "Diese Woche entfällt der Nachschreibetermin.",
                                        "Aufgrund einer Schulveranstaltung kann es heute vermehrt zu Ausfällen kommen.",
                                    ).random(),
                            ),
                            JournalNote(
                                description =
                                    listOf(
                                        "Heute ist der Fotograf in Mittagspause im Schulclub am Hauptstandort. Schülerinnen und Schüler, " +
                                            "die sich noch nicht fotografieren lassen konnten, haben nun die Chance, dies nachzuholen.",
                                        "Der Schulclub ist heute geschlossen.",
                                    ).random(),
                            ),
                        )
                    else -> emptyList()
                }
            val lessons =
                plan.mapIndexed { lessonIndex, subject ->
                    val slot = timeSlots[lessonIndex]
                    val rndStatus = Random.nextInt(100)
                    val status =
                        if (dayDate < nowDate) {
                            when {
                                rndStatus < 90 -> "hold"
                                rndStatus < 98 -> "canceled"
                                else -> "initial"
                            }
                        } else if (dayDate > nowDate) {
                            when {
                                rndStatus < 85 -> "initial"
                                rndStatus < 92 -> "planned"
                                else -> "canceled"
                            }
                        } else {
                            when {
                                rndStatus < 70 -> "hold"
                                rndStatus < 80 -> "canceled"
                                else -> "planned"
                            }
                        }
                    val rndNote = Random.nextInt(100)
                    val notes =
                        when {
                            rndNote < 5 ->
                                listOf(
                                    JournalNote(
                                        description = "Thema des Tests",
                                        type = JournalNoteType(name = "Test", color = "#27F54D"),
                                    ),
                                )
                            rndNote < 8 ->
                                listOf(
                                    JournalNote(
                                        description = "Thema der Klassenarbeit",
                                        type = JournalNoteType(name = "Klassenarbeit", color = "#F54927"),
                                    ),
                                )
                            rndNote < 10 ->
                                listOf(
                                    JournalNote(
                                        description = "In dieser Stunde findet irgendein besonderes Ereignis statt",
                                        type = JournalNoteType(name = "Ereignis"),
                                    ),
                                )
                            else -> emptyList()
                        }

                    JournalLesson(
                        id = "demo-$dayIndex-$lessonIndex",
                        nr = (lessonIndex + 1).toString(),
                        status = status,
                        times =
                            listOf(
                                TimeTableTimeLesson(
                                    id = "time-${lessonIndex + 1}",
                                    nr = (lessonIndex + 1).toString(),
                                    from = slot.first,
                                    to = slot.second,
                                ),
                            ),
                        time =
                            TimeTableTimeLesson(
                                id = "time-${lessonIndex + 1}",
                                nr = (lessonIndex + 1).toString(),
                                from = slot.first,
                                to = slot.second,
                            ),
                        subject = subject,
                        teachers = subject.teachers,
                        rooms = listOf(Room(id = lessonIndex, localId = "R${Random.nextInt(100, 300)}")),
                        notes = notes,
                    )
                }
            days.add(
                JournalDay(
                    id = "day-$dayIndex",
                    date = dayDate.toString(),
                    lessons = lessons,
                    notes = dayNotes,
                ),
            )
        }
        val weekId = "${monday.year}-${monday.weekOfYear}"
        return JournalWeek(
            id = weekId,
            calendarYear = monday.year,
            nr = monday.weekOfYear,
            days = days,
        )
    }

    private fun generateIntervalsForYear(year: Year): List<Interval> {
        val yearStart = LocalDate.parse(year.from)
        val firstHalfEnd = LocalDate(yearStart.year + 1, 1, 31)
        val secondHalfStart = LocalDate(yearStart.year + 1, 2, 1)

        val firstId = year.id * 10 + 1
        val secondId = year.id * 10 + 2
        val allIds = listOf(firstId.toString(), secondId.toString())

        return listOf(
            Interval(
                id = firstId,
                name = "1.HJ ${year.name}",
                type = "half_year",
                from = year.from,
                to = firstHalfEnd.toString(),
                editableTo = firstHalfEnd.toString(),
                intervalIds = allIds,
                yearId = year.id,
            ),
            Interval(
                id = secondId,
                name = "2.HJ ${year.name}",
                type = "half_year",
                from = secondHalfStart.toString(),
                to = year.to,
                editableTo = year.to,
                intervalIds = allIds,
                yearId = year.id,
            ),
        )
    }

    private fun generateAttendanceData(isCurrentYear: Boolean): DemoAttendanceData {
        val schoolDays = if (isCurrentYear) Random.nextInt(72, 138) else Random.nextInt(170, 196)
        val lessonsPerDay = Random.nextInt(5, 8)
        val lessonCount = (schoolDays * lessonsPerDay + Random.nextInt(-8, 13)).coerceAtLeast(1)

        val notPresentDaysWithAbsence = if (isCurrentYear) Random.nextInt(1, 8) else Random.nextInt(2, 13)
        val notPresentDaysWithoutAbsence = Random.nextInt(0, if (isCurrentYear) 3 else 5)

        var notPresentLessonsWithAbsence =
            (notPresentDaysWithAbsence * lessonsPerDay + Random.nextInt(0, lessonsPerDay + 2))
                .coerceAtMost(lessonCount - 1)
        var notPresentLessonsWithoutAbsence =
            (notPresentDaysWithoutAbsence * lessonsPerDay + Random.nextInt(0, 4))
                .coerceAtMost(lessonCount - 1)
        if (notPresentLessonsWithAbsence + notPresentLessonsWithoutAbsence >= lessonCount) {
            notPresentLessonsWithoutAbsence =
                (lessonCount - notPresentLessonsWithAbsence - 1)
                    .coerceAtLeast(0)
        }
        if (notPresentLessonsWithAbsence + notPresentLessonsWithoutAbsence >= lessonCount) {
            notPresentLessonsWithAbsence = (lessonCount - 1).coerceAtLeast(0)
            notPresentLessonsWithoutAbsence = 0
        }

        return DemoAttendanceData(
            schoolDays = schoolDays,
            lessonCount = lessonCount,
            notPresentDaysWithAbsence = notPresentDaysWithAbsence,
            notPresentDaysWithoutAbsence = notPresentDaysWithoutAbsence,
            notPresentLessonsWithAbsence = notPresentLessonsWithAbsence,
            notPresentLessonsWithoutAbsence = notPresentLessonsWithoutAbsence,
            tooLateSum = Random.nextInt(0, if (isCurrentYear) 8 else 16),
            tooEarlySum = Random.nextInt(0, if (isCurrentYear) 4 else 9),
            missingHomeworkSum = Random.nextInt(0, if (isCurrentYear) 5 else 13),
            missingEquipmentSum = Random.nextInt(0, if (isCurrentYear) 4 else 9),
        )
    }

    private fun DemoAttendanceData.toDayStudentCount(student: Student): JournalDayStudentCount =
        JournalDayStudentCount(
            count = schoolDays,
            lessonsCount = lessonCount.toString(),
            notPresentCount = notPresentDaysWithAbsence + notPresentDaysWithoutAbsence,
            notPresentWithAbsenceCount = notPresentDaysWithAbsence,
            notPresentWithoutAbsenceCount = notPresentDaysWithoutAbsence,
            studentId = student.id,
            student = student,
        )

    private fun DemoAttendanceData.toLessonStudentCount(student: Student): JournalLessonStudentCount =
        JournalLessonStudentCount(
            count = lessonCount,
            notPresentCount = notPresentLessonsWithAbsence + notPresentLessonsWithoutAbsence,
            notPresentWithAbsenceCount = notPresentLessonsWithAbsence,
            tooLateSum = tooLateSum,
            tooEarlySum = tooEarlySum,
            missingHomeworkSum = missingHomeworkSum,
            missingEquipmentSum = missingEquipmentSum,
            studentId = student.id,
            student = student,
        )

    private fun generateAbsencesForYear(
        year: Year,
        student: Student,
        subjects: List<Subject>,
        weekPlan: List<List<Subject>>,
        nowDate: LocalDate,
    ): List<Absence> {
        val fromDate = LocalDate.parse(year.from)
        val toDate = LocalDate.parse(year.to)
        val teacherPool = subjects.flatMap { it.teachers.orEmpty() }

        fun lessonTime(lessonIndex: Int): Pair<String, String> {
            val safeLessonIndex = lessonIndex.coerceIn(0, timeSlots.lastIndex)
            val slot = timeSlots[safeLessonIndex]
            return "${slot.first}:00" to "${slot.second}:00"
        }

        fun randomSchoolDay(): LocalDate {
            val span = fromDate.daysUntil(toDate).coerceAtLeast(1)
            var date = fromDate.plus(Random.nextInt(span + 1), DateTimeUnit.DAY)
            while (date.dayOfWeek == DayOfWeek.SATURDAY || date.dayOfWeek == DayOfWeek.SUNDAY) {
                date = date.plus(1, DateTimeUnit.DAY)
                if (date > toDate) date = date.minus(3, DateTimeUnit.DAY)
            }
            return date
        }

        fun addSchoolDays(
            date: LocalDate,
            days: Int,
        ): LocalDate {
            var current = date
            var remaining = days
            while (remaining > 0) {
                current = current.plus(1, DateTimeUnit.DAY)
                if (current.dayOfWeek != DayOfWeek.SATURDAY && current.dayOfWeek != DayOfWeek.SUNDAY) {
                    remaining--
                }
            }
            return current
        }

        val entries = mutableListOf<Absence>()
        val entriesCount = Random.nextInt(20, 30)
        repeat(entriesCount) { index ->
            val id = (year.id * 1000) + index + 1
            val teacher = teacherPool.random()
            val conductor =
                Conductor(
                    id = teacher.id ?: 0,
                    localId = teacher.localId,
                    forename = teacher.forename,
                    name = teacher.name,
                )

            val kindRoll = Random.nextInt(100)
            val startDate = randomSchoolDay()
            val from: String
            val to: String
            when {
                kindRoll < 40 -> {
                    val duration =
                        when (Random.nextInt(100)) {
                            in 0..61 -> 1
                            in 62..89 -> 2
                            else -> 3
                        }
                    var endDate = addSchoolDays(startDate, duration - 1)
                    if (endDate > toDate) endDate = toDate
                    from = "$startDate 00:00:00"
                    to = "$endDate 23:59:59"
                }
                kindRoll < 70 -> {
                    val dayIndex = startDate.dayOfWeek.isoDayNumber.let { (it - 1).coerceIn(0, 4) }
                    val lessonsPerDay = weekPlan.getOrNull(dayIndex)?.size ?: 6
                    val startLessonUpperBound = (lessonsPerDay - 1).coerceAtLeast(1)
                    val startLesson = Random.nextInt(0, startLessonUpperBound)
                    val endLesson = (startLesson + Random.nextInt(1, 4)).coerceAtMost(lessonsPerDay - 1)
                    val (startTime, _) = lessonTime(startLesson)
                    val (_, endTime) = lessonTime(endLesson)
                    from = "$startDate $startTime"
                    to = "$startDate $endTime"
                }
                else -> {
                    val dayIndex = startDate.dayOfWeek.isoDayNumber.let { (it - 1).coerceIn(0, 4) }
                    val lessonsPerDay = weekPlan.getOrNull(dayIndex)?.size ?: 6
                    val lesson = Random.nextInt(0, lessonsPerDay.coerceAtLeast(1))
                    val (startTime, endTime) = lessonTime(lesson)
                    from = "$startDate $startTime"
                    to = "$startDate $endTime"
                }
            }

            val typeName =
                if (kindRoll >= 40) {
                    "Schulveranstaltung"
                } else {
                    when (Random.nextInt(100)) {
                        in 0..59 -> "Krank"
                        in 60..84 -> "Schulveranstaltung"
                        else -> "Entschuldigt"
                    }
                }

            val absenceType =
                AbsenceType(
                    id = 0,
                    name = typeName,
                    default = 0,
                    editableAs = "absence",
                )

            val recordedDate = startDate.minus(Random.nextInt(0, 3), DateTimeUnit.DAY)
            val recordedAt = "$recordedDate ${listOf("07:10:00", "07:25:00", "08:05:00", "12:15:00").random()}"
            val confirmed = Random.nextInt(100) < 82
            val verificationRecordedAt =
                if (confirmed) {
                    "$startDate ${listOf("08:00:00", "10:20:00", "13:45:00").random()}"
                } else {
                    null
                }

            val histories =
                buildList {
                    add(
                        History(
                            id = id * 10,
                            historyEntryType = "absence",
                            historyEntryId = id,
                            body = "Created",
                            action = "created",
                            conductorType = "teacher",
                            conductor = conductor,
                        ),
                    )
                    if (confirmed) {
                        add(
                            History(
                                id = id * 10 + 1,
                                historyEntryType = "absence_verification",
                                historyEntryId = id,
                                body = "Created",
                                action = "created",
                                conductorType = "teacher",
                                conductor = conductor,
                            ),
                        )
                    }
                }

            entries.add(
                Absence(
                    id = id,
                    from = from,
                    to = to,
                    recordedAt = recordedAt,
                    type = absenceType,
                    teacher = teacher,
                    student = student,
                    verification =
                        AbsenceVerification(
                            id = id.toString(),
                            confirmed = confirmed,
                            recordedAt = verificationRecordedAt,
                            teacher = teacher,
                        ),
                    histories = histories,
                ),
            )
        }

        if (nowDate in fromDate..toDate) {
            fun toSchoolDay(date: LocalDate): LocalDate {
                var result = date
                if (result.dayOfWeek == DayOfWeek.SATURDAY) result = result.plus(2, DateTimeUnit.DAY)
                if (result.dayOfWeek == DayOfWeek.SUNDAY) result = result.plus(1, DateTimeUnit.DAY)
                if (result < fromDate) result = fromDate
                if (result > toDate) result = toDate
                while (result.dayOfWeek == DayOfWeek.SATURDAY || result.dayOfWeek == DayOfWeek.SUNDAY) {
                    result = result.minus(1, DateTimeUnit.DAY)
                    if (result < fromDate) {
                        result = result.plus(3, DateTimeUnit.DAY)
                    }
                }
                return result
            }

            val teacher = teacherPool.random()
            val conductor =
                Conductor(
                    id = teacher.id ?: 0,
                    localId = teacher.localId,
                    forename = teacher.forename,
                    name = teacher.name,
                )
            val referenceDate = toSchoolDay(nowDate)
            val fullDayDuration = Random.nextInt(1, 3)
            var fullDayTo = addSchoolDays(referenceDate, fullDayDuration - 1)
            if (fullDayTo > toDate) fullDayTo = toDate

            val ensuredIdBase = year.id * 1000 + entriesCount + 200
            entries.add(
                Absence(
                    id = ensuredIdBase,
                    from = "$referenceDate 00:00:00",
                    to = "$fullDayTo 23:59:59",
                    recordedAt = "${referenceDate.minus(1, DateTimeUnit.DAY)} 07:20:00",
                    type = AbsenceType(id = 1, name = "Krankheit", default = 0, editableAs = "absence"),
                    teacher = teacher,
                    student = student,
                    verification =
                        AbsenceVerification(
                            id = ensuredIdBase.toString(),
                            confirmed = true,
                            recordedAt = "$referenceDate 08:00:00",
                            teacher = teacher,
                        ),
                    histories =
                        listOf(
                            History(
                                id = ensuredIdBase * 10,
                                historyEntryType = "absence",
                                historyEntryId = ensuredIdBase,
                                body = "Created",
                                action = "created",
                                conductorType = "teacher",
                                conductor = conductor,
                            ),
                            History(
                                id = ensuredIdBase * 10 + 1,
                                historyEntryType = "absence_verification",
                                historyEntryId = ensuredIdBase,
                                body = "Created",
                                action = "created",
                                conductorType = "teacher",
                                conductor = conductor,
                            ),
                        ),
                ),
            )

            val monday = referenceDate.minus(referenceDate.dayOfWeek.isoDayNumber - 1, DateTimeUnit.DAY)

            fun pickSchoolDayForPartial(): LocalDate {
                var day = monday.plus(Random.nextInt(0, 5), DateTimeUnit.DAY)
                if (day < fromDate) day = fromDate
                if (day > toDate) day = toDate
                var tries = 0
                while (day in referenceDate..fullDayTo && tries < 6) {
                    day = day.plus(1, DateTimeUnit.DAY)
                    if (day.dayOfWeek == DayOfWeek.SATURDAY || day.dayOfWeek == DayOfWeek.SUNDAY || day > toDate) {
                        day = monday.plus(Random.nextInt(0, 5), DateTimeUnit.DAY)
                    }
                    tries++
                }
                while (day.dayOfWeek == DayOfWeek.SATURDAY || day.dayOfWeek == DayOfWeek.SUNDAY) {
                    day = day.minus(1, DateTimeUnit.DAY)
                }
                if (day < fromDate) return fromDate
                if (day > toDate) return toDate
                return day
            }

            fun addPartialAbsence(
                id: Int,
                date: LocalDate,
                forceMultiHour: Boolean = false,
            ) {
                val lessonsPerDay = weekPlan.getOrNull((date.dayOfWeek.isoDayNumber - 1).coerceIn(0, 4))?.size ?: 6
                val lessonIndex =
                    if (forceMultiHour) {
                        val upperBound = (lessonsPerDay - 1).coerceAtLeast(1)
                        Random.nextInt(0, upperBound)
                    } else {
                        Random.nextInt(0, lessonsPerDay.coerceAtLeast(1))
                    }
                val endLessonIndex =
                    if (forceMultiHour) {
                        (lessonIndex + Random.nextInt(1, 3)).coerceAtMost(lessonsPerDay - 1)
                    } else {
                        (lessonIndex + Random.nextInt(0, 2)).coerceAtMost(lessonsPerDay - 1)
                    }
                val (fromTime, _) = lessonTime(lessonIndex)
                val (_, toTime) = lessonTime(endLessonIndex)
                entries.add(
                    Absence(
                        id = id,
                        from = "$date $fromTime",
                        to = "$date $toTime",
                        recordedAt = "$date 07:25:00",
                        type = AbsenceType(id = 2, name = "Schulveranstaltung", default = 0, editableAs = "absence"),
                        teacher = teacher,
                        student = student,
                        histories =
                            listOf(
                                History(
                                    id = id * 10,
                                    historyEntryType = "absence",
                                    historyEntryId = id,
                                    body = "Created",
                                    action = "created",
                                    conductorType = "teacher",
                                    conductor = conductor,
                                ),
                            ),
                    ),
                )
            }

            addPartialAbsence(ensuredIdBase + 1, pickSchoolDayForPartial(), forceMultiHour = true)
        }

        return entries.sortedByDescending { it.from }
    }
}
