package com.hansholz.bestenotenapp.notifications

import androidx.compose.runtime.mutableStateListOf
import androidx.compose.runtime.mutableStateOf
import com.hansholz.bestenotenapp.api.BesteSchuleApi
import com.hansholz.bestenotenapp.api.createHttpClient
import com.hansholz.bestenotenapp.api.models.Grade
import com.hansholz.bestenotenapp.api.models.GradeCollection
import com.hansholz.bestenotenapp.security.kSafe
import io.ktor.client.plugins.ClientRequestException
import kotlinx.coroutines.CancellationException
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json

// Pre-generated by AI

internal enum class GradeNotificationOutcome {
    Success,
    Retry,
}

internal object GradeNotificationEngine {
    private const val KEY_KNOWN_GRADE_IDS = "gradeNotificationsKnownGradeIds"

    private val json = Json { ignoreUnknownKeys = true }
    private val kSafe = kSafe()

    fun isEnabled(): Boolean = kSafe.getDirect("gradeNotificationsEnabled", false)

    fun getIntervalMinutes(): Long = kSafe.getDirect("gradeNotificationsIntervalMinutes", 60L)

    fun isWifiOnlyEnabled(): Boolean = kSafe.getDirect("gradeNotificationsWifiOnly", false)

    fun shouldSchedule(): Boolean = isEnabled() && hasCredentials()

    fun clearKnownGrades() {
        kSafe.deleteDirect(KEY_KNOWN_GRADE_IDS)
    }

    suspend fun runCheck(): GradeNotificationOutcome {
        if (!shouldSchedule()) return GradeNotificationOutcome.Success

        val studentId = kSafe.getDirect<String?>("studentId", null) ?: return GradeNotificationOutcome.Success
        val token = kSafe.getDirect<String?>("authToken", null) ?: return GradeNotificationOutcome.Success

        val httpClient = createHttpClient()
        return try {
            val authState = mutableStateOf<String?>(token)
            val studentState = mutableStateOf<String?>(studentId)
            val api = BesteSchuleApi(httpClient, authState, studentState)
            val collections = fetchAllCollections(api)
            val currentIds = collections.flatMap { it.grades.orEmpty() }.map { it.id }.toSet()

            val knownIds = loadKnownGradeIds()
            val newIds = currentIds - knownIds

            if (newIds.isNotEmpty() && knownIds.isNotEmpty()) {
                val newGrades =
                    collections
                        .flatMap { collection ->
                            collection.grades
                                .orEmpty()
                                .filter { it.id in newIds }
                                .map { it to collection }
                        }.sortedBy { it.second.givenAt }
                notifyNewGrades(newGrades)
            }

            storeKnownGradeIds(currentIds)
            GradeNotificationOutcome.Success
        } catch (e: CancellationException) {
            throw e
        } catch (e: ClientRequestException) {
            if (e.response.status.value == 401) {
                GradeNotificationOutcome.Success
            } else {
                GradeNotificationOutcome.Retry
            }
        } catch (e: Exception) {
            e.printStackTrace()
            GradeNotificationOutcome.Retry
        } finally {
            httpClient.close()
        }
    }

    private fun hasCredentials(): Boolean {
        val studentId = kSafe.getDirect<String?>("studentId", null)
        val token = kSafe.getDirect<String?>("authToken", null)
        return !studentId.isNullOrBlank() && !token.isNullOrBlank()
    }

    private suspend fun fetchAllCollections(api: BesteSchuleApi): List<GradeCollection> {
        val includes = listOf("grades")
        val collections = mutableStateListOf<GradeCollection>()

        val collection = api.collectionsIndex(include = includes)
        collections.addAll(collection.data)
        if ((collection.meta?.lastPage ?: 0) > 1) {
            for (i in 2..(collection.meta?.lastPage ?: 0)) {
                collections.addAll(api.collectionsIndex(include = includes, page = i).data)
            }
        }

        return collections
    }

    private fun notifyNewGrades(entries: List<Pair<Grade, GradeCollection>>) {
        if (entries.isEmpty()) return

        val notifications =
            entries.map { (grade, collection) ->
                val title = collection.subject?.name?.let { "Neue Note in $it" } ?: "Neue Note"
                val body = "Bei " + (collection.name ?: "einer unbekannten Leistung") + " hast du die Note " + grade.value + " erreicht"
                GradeNotificationPayload(
                    id = grade.id.toString(),
                    title = title,
                    body = body,
                )
            }

        GradeNotificationNotifier.notifyNewGrades(notifications)
    }

    private fun loadKnownGradeIds(): Set<Int> {
        val raw = kSafe.getDirect<String?>(KEY_KNOWN_GRADE_IDS, null) ?: return emptySet()
        return runCatching { json.decodeFromString<KnownGrades>(raw).ids.toSet() }.getOrElse { emptySet() }
    }

    private fun storeKnownGradeIds(ids: Set<Int>) {
        val payload = json.encodeToString(KnownGrades(ids.toList()))
        kSafe.putDirect(KEY_KNOWN_GRADE_IDS, payload)
    }

    @Serializable
    private data class KnownGrades(
        val ids: List<Int>,
    )
}
