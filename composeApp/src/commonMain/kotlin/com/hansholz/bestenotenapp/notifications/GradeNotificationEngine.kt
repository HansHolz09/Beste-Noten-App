package com.hansholz.bestenotenapp.notifications

import androidx.compose.runtime.mutableStateListOf
import androidx.compose.runtime.mutableStateOf
import com.hansholz.bestenotenapp.api.BesteSchuleApi
import com.hansholz.bestenotenapp.api.createHttpClient
import com.hansholz.bestenotenapp.api.models.Grade
import com.hansholz.bestenotenapp.api.models.GradeCollection
import com.hansholz.bestenotenapp.security.AuthTokenManager
import com.russhwolf.settings.Settings
import io.ktor.client.plugins.ClientRequestException
import kotlinx.coroutines.CancellationException
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json

/* Pre-generated by AI */

internal enum class GradeNotificationOutcome {
    Success,
    Retry
}

internal object GradeNotificationEngine {
    private const val KEY_KNOWN_GRADE_IDS = "gradeNotificationsKnownGradeIds"

    private val json = Json { ignoreUnknownKeys = true }
    private val settings = Settings()
    private val authTokenManager = AuthTokenManager()

    fun isEnabled(): Boolean = settings.getBoolean("gradeNotificationsEnabled", false)

    fun getIntervalMinutes(): Long =
        settings.getLong("gradeNotificationsIntervalMinutes", 60L)

    fun isWifiOnlyEnabled(): Boolean = settings.getBoolean("gradeNotificationsWifiOnly", false)

    fun shouldSchedule(): Boolean = isEnabled() && hasCredentials()

    fun clearKnownGrades() {
        settings.remove(KEY_KNOWN_GRADE_IDS)
    }

    suspend fun runCheck(): GradeNotificationOutcome {
        if (!shouldSchedule()) return GradeNotificationOutcome.Success

        val studentId = settings.getStringOrNull("studentId") ?: return GradeNotificationOutcome.Success
        val token = authTokenManager.getToken()
        if (token.isNullOrBlank()) return GradeNotificationOutcome.Success

        val httpClient = createHttpClient()
        return try {
            val authState = mutableStateOf<String?>(token)
            val studentState = mutableStateOf<String?>(studentId)
            val api = BesteSchuleApi(httpClient, authState, studentState)
            val collections = fetchAllCollections(api)
            val currentIds = collections.flatMap { it.grades.orEmpty() }.map { it.id }.toSet()

            val knownIds = loadKnownGradeIds()
            val newIds = currentIds - knownIds

            if (newIds.isNotEmpty() && knownIds.isNotEmpty()) {
                val newGrades = collections.flatMap { collection ->
                    collection.grades.orEmpty()
                        .filter { it.id in newIds }
                        .map { it to collection }
                }.sortedBy { it.second.givenAt }
                notifyNewGrades(newGrades)
            }

            storeKnownGradeIds(currentIds)
            GradeNotificationOutcome.Success
        } catch (e: CancellationException) {
            throw e
        } catch (e: ClientRequestException) {
            if (e.response.status.value == 401) {
                GradeNotificationOutcome.Success
            } else {
                GradeNotificationOutcome.Retry
            }
        } catch (e: Exception) {
            e.printStackTrace()
            GradeNotificationOutcome.Retry
        } finally {
            httpClient.close()
        }
    }

    private fun hasCredentials(): Boolean {
        val studentId = settings.getStringOrNull("studentId")
        val token = authTokenManager.getToken()
        return !studentId.isNullOrBlank() && !token.isNullOrBlank()
    }

    private suspend fun fetchAllCollections(api: BesteSchuleApi): List<GradeCollection> {
        val includes = listOf("grades")
        val collections = mutableStateListOf<GradeCollection>()

        val collection = api.collectionsIndex(include = includes)
        collections.addAll(collection.data)
        if ((collection.meta?.lastPage ?: 0) > 1) {
            for (i in 2..(collection.meta?.lastPage ?: 0)) {
                collections.addAll(api.collectionsIndex(include = includes, page = i).data)
            }
        }

        return collections
    }

    private fun notifyNewGrades(entries: List<Pair<Grade, GradeCollection>>) {
        if (entries.isEmpty()) return

        val notifications = entries.map { (grade, collection) ->
            val title = collection.subject?.name?.let { "Neue Note in $it" } ?: "Neue Note"
            val body = "Bei " + (collection.name ?: "einer unbekannten Leistung") + " hast du die Note " + grade.value + " erreicht"
            GradeNotificationPayload(
                id = grade.id.toString(),
                title = title,
                body = body
            )
        }

        GradeNotificationNotifier.notifyNewGrades(notifications)
    }

    private fun loadKnownGradeIds(): Set<Int> {
        val raw = settings.getStringOrNull(KEY_KNOWN_GRADE_IDS) ?: return emptySet()
        return runCatching { json.decodeFromString<KnownGrades>(raw).ids.toSet() }.getOrElse { emptySet() }
    }

    private fun storeKnownGradeIds(ids: Set<Int>) {
        val payload = json.encodeToString(KnownGrades(ids.toList()))
        settings.putString(KEY_KNOWN_GRADE_IDS, payload)
    }

    @Serializable
    private data class KnownGrades(val ids: List<Int>)
}
